#!/usr/bin/env ruby

require 'rubygems'
require 'tmpdir'
require 'vagrant'
require 'erb'
require 'fileutils'
require 'net/ssh'
require 'net/ssh/shell'
require 'logger'
require "fcntl"

class VagrantGo
  class Error < StandardError; end
  class TimeoutError < StandardError; end
  class CommandFailedError < StandardError; end

  ROOT             = File.expand_path("../..", __FILE__)
  TEMPLATE_PATH    = File.join(ROOT, "Vagrantfile.erb")
  PUPPET_PATH      = File.join(ROOT, "puppet")
  VM_REPO_PATH     = "/selenium-trunk"

  COMMAND_TIMEOUT        = 30
  VM_LOCK_TIMEOUT        = 60*15
  SSH_CONNECTION_TIMEOUT = 20

  def initialize(args)
    parse_args args

    unless File.exist?(File.join(@repo, "go"))
      raise Error, "not a selenium repo ('go' not found): #{@repo.inspect}"
    end
  end

  def execute
    $stdout.sync = true
    $stderr.sync = true

    in_vm_dir {
      begin
        launch_vm
        prepare_environment
        run_build
      ensure
        destroy_vm  # ideally roll back to snapshot
      end
    }
  end

  def write_vagrantfile_to(dest_dir)
    unless File.directory? dest_dir
      raise ArgumentError, "#{dest_dir} is not a directory"
    end

    # vars used by template
    puppet_path   = PUPPET_PATH
    repo_path     = @repo
    vm_repo_path  = VM_REPO_PATH
    manifest_file = "#{@manifest}.pp"

    destination = File.join(dest_dir, "Vagrantfile")
    log.info "creating Vagrantfile [#{destination}] for #{repo_path}"

    File.open(destination, "w") do |io|
      io << ERB.new(template, nil, "%-<>").result(binding)
    end
  end

  private

  def parse_args(args)
    if args.empty?
      puts <<-HELP

    #{File.basename $PROGRAM_NAME} [options] [targets]

    Options:

      -Xmanifest=<name> - what manifest to use for the VM (default: firefox)
      -Xrepo=<name>     - path to selenium checkout (default: cwd)

      HELP
      exit 1
    end

    opts = {}

    xargs = args.select { |arg|
      case arg
      when /^-X(.+)=(.+)$/
        opts[$1] = $2
        true
      when /^-X(.+)$/
        opts[$1] = true
      else
        false
      end
    }


    @targets  = args - xargs
    @manifest = opts.delete('manifest') || 'firefox'
    @repo     = File.expand_path(opts.delete('repo') || Dir.pwd) # assume we're running from a checkout

    unless opts.empty?
      raise ArgumentError, "unknown options #{opts.inspect}"
    end
  end

  def launch_vm
    log.info "launching VM from #{Dir.pwd}"
    with_lock_guard { vagrant.cli "up" }
  end

  def destroy_vm
    log.info "destroying VM from #{Dir.pwd}"
    with_lock_guard { vagrant.cli "destroy" }
  end

  def in_vm_dir(&blk)
    log.info "creating #{@manifest} VM for `#{target_string}` #{@repo}"

    vm_dir = Dir.mktmpdir
    write_vagrantfile_to vm_dir

    begin
      Dir.chdir(vm_dir, &blk)
    ensure
      FileUtils.rm_rf vm_dir
    end
  end

  def vagrant
    @vagrant ||= (
      ENV['VAGRANT_LOG'] = "STDOUT"
      Vagrant::Environment.new
    )
  end

  def template
    File.read(TEMPLATE_PATH)
  end

  def prepare_environment
    run_command "cd #{VM_REPO_PATH}"
  end

  def run_build
    run_command "./go #{target_string}"
  rescue TimeoutError
    in_separate_shell { save_screenshot }
  end

  def target_string
    @target_string ||= @targets.join(' ')
  end

  def shell
    @shell ||= new_shell
  end

  def new_shell
    Net::SSH.start('localhost', 'vagrant', :port    => ssh_port,
                                           :keys    => [vagrant.primary_vm.env.config.ssh.private_key_path],
                                           :timeout => SSH_CONNECTION_TIMEOUT # initial connection
    ).shell
  end

  def exec(command, out = $stdout, err = $stderr)
    start_time = Time.now
    status     = nil

    shell.execute(command) do |process|
      process.on_output       { |prc, data| out.print data }
      process.on_error_output { |prc, data| err.print data }
      process.on_finish       { |prc| status = prc.exit_status }
    end

    shell.session.loop(0.5) do
      if Time.now >= (start_time + COMMAND_TIMEOUT)
        raise TimeoutError, "command timed out after #{COMMAND_TIMEOUT} seconds: #{command}"
      end

      status.nil?
    end

    status
  end

  def ssh_port
    @ssh_port ||= (
      locked {
        server = TCPServer.new("127.0.0.1", 0)
        port   = server.addr[1]
        server.close

        port
      }
    )
  end

  def in_separate_shell(&blk)
    old_shell = @shell
    @shell = new_shell

    begin
      yield
    ensure
      @shell.close!
      @shell = old_shell
    end
  end

  def with_lock_guard(&blk)
    start_time = Time.now
    begin
      yield
    rescue Vagrant::Errors::EnvironmentLockedError
      if Time.now > (start_time + VM_LOCK_TIMEOUT)
        raise TimeoutError, "timed out after #{VM_LOCK_TIMEOUT} seconds, waiting for vm lock"
      end

      log.info "waiting for vm lock"
      sleep 1
      retry
    end
  end

  def locked(&blk)
    FileUtils.mkdir_p File.dirname(lock_path)
    start_time = Time.now

    File.open(lock_path, "w+") { |f|
      f.fcntl Fcntl::F_SETFD, Fcntl::FD_CLOEXEC

      while f.flock(File::LOCK_EX | File::LOCK_NB) === false
        log.info "waiting for #{lock_path.inspect}"

        if Time.now >= (start_time + VM_LOCK_TIMEOUT)
          raise Error, "timed out after #{VM_LOCK_TIMEOUT} seconds waiting for lock on #{lock_path.inspect}"
        end

        sleep 1
      end

      yield
    }
  end

  def lock_path
    @lock_path ||= File.join(ROOT, "tmp", "find-free-port.lock")
  end

  def log
    @log ||= Logger.new(STDOUT)
  end

  def run_command(cmd)
    status = 0

    log.info "executing command: #{cmd}"
    status = exec(cmd)
    log.info "exit status #{status}    : #{cmd}"

    if status != 0
      raise CommandFailedError, "command exited with status #{status}: #{cmd.inspect}"
    end
  end

  def save_screenshot
    screenshot = File.join(VM_REPO_PATH, 'build', "vagrant-screenshot.jpg")
    log.info "saving screenshot to #{screenshot}"

    status = exec("~/take-screenshot.sh > #{screenshot}")
    log.warn "failed to save screenshot" if status != 0
  end

  def output_dir
    @output_dir ||= (
      dir = File.join(@repo, 'build', 'vagrant')
      FileUtils.mkdir_p dir

      dir
    )
  end

  def xvfb_running?
    status = exec "/etc/init.d/xvfb status" # did xvfb die during the build?
    log.info "xvfb status: #{status}"

    status == 0
  end
end

if __FILE__ == $0
  exit 1 if ARGV.empty?
  VagrantGo.new(ARGV).execute
end
