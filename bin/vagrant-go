#!/usr/bin/env ruby

require 'rubygems'
require 'tmpdir'
require 'vagrant'
require 'erb'
require 'fileutils'
require 'net/ssh'
require 'net/ssh/shell'
require 'logger'

class VagrantGo
  class Error < StandardError
  end

  ROOT          = File.expand_path("../..", __FILE__)
  TEMPLATE_PATH = File.join(ROOT, "Vagrantfile.erb")
  PUPPET_PATH   = File.join(ROOT, "puppet")

  TIMEOUT = 60*30 # 30 minutes should be enough

  def initialize(targets)
    @targets = targets
    @repo = Dir.pwd # command expected to be run from source checkout.

    unless File.exist?(File.join(@repo, "go"))
      raise Error, "not a selenium repo ('go' not found): #{repo.inspect}"
    end
  end

  def execute
    $stdout.sync = true
    $stderr.sync = true

    in_vm_dir {
      begin
        launch_vm
        run_commands
      ensure
        destroy_vm  # ideally roll back to snapshot
      end
    }
  end

  private

  def launch_vm
    log.info "launching VM from #{Dir.pwd}"
    vagrant.cli "up"
  end

  def destroy_vm
    log.info "destroying VM from #{Dir.pwd}"
    vagrant.cli "destroy"
  end

  def run_commands
    commands.each do |cmd|
      log.info "executing command: #{cmd.inspect}"
      status = exec(cmd)
      if status != 0
        msg = "command exited with status #{status}: #{cmd.inspect}"
        log.error msg
        raise Error, msg
      else
        log.info "executing command: #{cmd.inspect} exited with status #{status}"
      end
    end
  end

  def in_vm_dir(&blk)
    vm_dir = Dir.mktmpdir

    # vars used by template
    puppet_path = PUPPET_PATH
    repo_path   = @repo

    destination = File.join(vm_dir, "Vagrantfile")
    log.info "creating Vagrantfile [#{destination}] for #{repo_path}"

    File.open(destination, "w") do |io|
      io << ERB.new(template, nil, "%-<>").result(binding)
    end

    begin
      Dir.chdir(vm_dir, &blk)
    ensure
      FileUtils.rm_rf vm_dir
    end
  end

  def vagrant
    @vagrant ||= (
      ENV['VAGRANT_LOG'] = "STDOUT"
      Vagrant::Environment.new(:lock_path => lock_path)
    )
  end

  def template
    File.read(TEMPLATE_PATH)
  end

  def lock_path
    File.join(Dir.pwd, 'vagrant-selenium-ci.lock')
  end

  def commands
    [
      "export DISPLAY=:1",
      "export PATH=/tmp/firefox/:$PATH",
      "cd /selenium-trunk",
      "./go #{@targets.join ' '}"
    ]
  end

  def shell
    @shell ||= (
      Net::SSH.start('localhost', 'vagrant', :port    => ssh_port,
                                             :keys    => [vagrant.primary_vm.env.config.ssh.private_key_path],
                                             :timeout => 20 # initial connection
      ).shell
    )
  end

  def exec(command)
    start_time = Time.now
    status     = nil

    shell.execute(command) do |process|
      process.on_output       { |prc, data| $stdout.print data }
      process.on_error_output { |prc, data| $stderr.print data }
      process.on_finish       { |prc| status = prc.exit_status }
    end

    shell.session.loop do
      if Time.now >= (start_time + TIMEOUT)
        raise "command timed out after #{TIMEOUT} seconds: #{command}"
      end

      status.nil?
    end

    status
  end

  def ssh_port
    @ssh_port ||= (
      server = TCPServer.new("127.0.0.1", 0)
      port   = server.addr[1]
      server.close

      port
    )
  end

  def log
    @log ||= Logger.new(STDOUT)
  end
end

if __FILE__ == $0
  exit 1 if ARGV.empty?
  VagrantGo.new(ARGV).execute
end
