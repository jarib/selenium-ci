#!/usr/bin/env ruby

require 'rubygems'
require 'tmpdir'
require 'vagrant'
require 'erb'
require 'fileutils'
require 'net/ssh'
require 'net/ssh/shell'
require 'logger'
require "fcntl"

class VagrantGo
  class Error < StandardError
  end

  ROOT             = File.expand_path("../..", __FILE__)
  TEMPLATE_PATH    = File.join(ROOT, "Vagrantfile.erb")
  PUPPET_PATH      = File.join(ROOT, "puppet")
  VAGRANT_BOX_PATH = File.join(ROOT, "tmp/selenium-ci.box")
  VAGRANT_BOX_URL  = "http://files.jaribakken.com/selenium2/selenium-ci.box"

  COMMAND_TIMEOUT        = 60*30
  VM_LOCK_TIMEOUT        = 60*15
  SSH_CONNECTION_TIMEOUT = 20

  def initialize(targets)
    @targets = targets
    @repo = Dir.pwd # command expected to be run from source checkout.

    unless File.exist?(File.join(@repo, "go"))
      raise Error, "not a selenium repo ('go' not found): #{@repo.inspect}"
    end
  end

  def execute
    $stdout.sync = true
    $stderr.sync = true

    in_vm_dir {
      begin
        launch_vm
        run_commands
      ensure
        destroy_vm  # ideally roll back to snapshot
      end
    }
  end

  private

  def launch_vm
    log.info "launching VM from #{Dir.pwd}"
    with_lock_guard { vagrant.cli "up" }
  end

  def destroy_vm
    log.info "destroying VM from #{Dir.pwd}"
    with_lock_guard { vagrant.cli "destroy" }
  end

  def run_commands
    status = 0

    commands.each do |cmd|
      log.info "executing command: #{cmd}"
      status = exec(cmd)
      log.info "exit status #{status}    : #{cmd}"

      if status != 0
        raise Error, "command exited with status #{status}: #{cmd.inspect}"
      end
    end
  ensure
    if status != 0
      check_xvfb_status
    end
  end

  def in_vm_dir(&blk)
    vm_dir = Dir.mktmpdir

    # vars used by template
    puppet_path = PUPPET_PATH
    repo_path   = @repo

    destination = File.join(vm_dir, "Vagrantfile")
    log.info "creating Vagrantfile [#{destination}] for #{repo_path}"

    File.open(destination, "w") do |io|
      io << ERB.new(template, nil, "%-<>").result(binding)
    end

    begin
      Dir.chdir(vm_dir, &blk)
    ensure
      FileUtils.rm_rf vm_dir
    end
  end

  def vagrant
    @vagrant ||= (
      ENV['VAGRANT_LOG'] = "STDOUT"
      Vagrant::Environment.new
    )
  end

  def template
    File.read(TEMPLATE_PATH)
  end

  def commands
    [
      "export DISPLAY=:1",
      "export PATH=/tmp/firefox/:$PATH",
      "cd /selenium-trunk",
      "./go #{@targets.join ' '}"
    ]
  end

  def shell
    @shell ||= (
      Net::SSH.start('localhost', 'vagrant', :port    => ssh_port,
                                             :keys    => [vagrant.primary_vm.env.config.ssh.private_key_path],
                                             :timeout => SSH_CONNECTION_TIMEOUT # initial connection
      ).shell
    )
  end

  def exec(command)
    start_time = Time.now
    status     = nil

    shell.execute(command) do |process|
      process.on_output       { |prc, data| $stdout.print data }
      process.on_error_output { |prc, data| $stderr.print data }
      process.on_finish       { |prc| status = prc.exit_status }
    end

    shell.session.loop do
      if Time.now >= (start_time + COMMAND_TIMEOUT)
        raise "command timed out after #{COMMAND_TIMEOUT} seconds: #{command}"
      end

      status.nil?
    end

    status
  end

  def ssh_port
    @ssh_port ||= (
      locked {
        server = TCPServer.new("127.0.0.1", 0)
        port   = server.addr[1]
        server.close

        port
      }
    )
  end

  def box_url
    unless File.exist?(VAGRANT_BOX_PATH)
      raise Error, "please download #{VAGRANT_BOX_URL} to #{VAGRANT_BOX_PATH} for concurrent VMs"
    end

    VAGRANT_BOX_PATH
  end

  def with_lock_guard(&blk)
    start_time = Time.now
    begin
      yield
    rescue Vagrant::Errors::EnvironmentLockedError
      if Time.now > (start_time + VM_LOCK_TIMEOUT)
        raise Error, "timed out after #{VM_LOCK_TIMEOUT} seconds, waiting for vm lock"
      end

      log.info "waiting for vm lock"
      sleep 1
      retry
    end
  end

  def locked(&blk)
    start_time = Time.now

    FileUtils.mkdir_p File.dirname(lock_path)

    File.open(lock_path, "w+") { |f|
      f.fcntl Fcntl::F_SETFD, Fcntl::FD_CLOEXEC

      while f.flock(File::LOCK_EX | File::LOCK_NB) === false
        log.info "waiting for #{lock_path.inspect}"

        if Time.now >= (start_time + VM_LOCK_TIMEOUT)
          raise Error, "timed out after #{VM_LOCK_TIMEOUT} seconds waiting for lock on #{lock_path.inspect}"
        end

        sleep 1
      end

      yield
    }
  end

  def lock_path
    @lock_path ||= File.join(ROOT, "tmp", "find-free-port.lock")
  end

  def log
    @log ||= Logger.new(STDOUT)
  end

  def check_xvfb_status
    log.warn "checking xvfb status"
    status = exec "/etc/init.d/xvfb status" # did xvfb die during the build?
    log.error "could not check xvfb status" if status != 0
  end
end

if __FILE__ == $0
  exit 1 if ARGV.empty?
  VagrantGo.new(ARGV).execute
end
